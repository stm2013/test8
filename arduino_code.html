<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Arduino code</title>
</head>
<body>
<h1>Main code</h1>
<p>This program does the coarse and fine approaching as well as scanning the sample.  </p>
<xmp>
    #include <SPI.h>

    // ___ STEPPER MOTOR ___
    const int inputPin = 1;
    const int IN1 = 8;
    const int IN2 = 9;
    const int IN3 = 10;
    const int IN4 = 11;

    boolean current = false;
    int tunnelRead = 0; // aktuell tunnelström
    int tunnelRef = 0; // tunnelström som vi vill ha
    int marginal = 200;

    int steps = 0;
    boolean stepperDirec = true;

    // ___ PIEZO ACTUATORS ___
    const int pinpX = 4;
    const int pinnX = 5;
    const int pinpY = 6;
    const int pinnY = 7;

    long pX = 0;
    long nX = 0;
    long pY = 0;
    long nY = 0;

    long scanArray[1600];
    int currentPos = 0;

    boolean adjusted = false;

    const int Vref = 1;

    const int M = 20;
    const int N = 20;


    void setup() {
    //Serial.begin(9600); // datahastighet bitar/s. Bör ökas
    analogWriteResolution(10); // upplösning i bytes
    analogReadResolution(12);


    // stepper
    pinMode(IN1, OUTPUT);
    pinMode(IN2, OUTPUT);
    pinMode(IN3, OUTPUT);
    pinMode(IN4, OUTPUT);


    // piezo
    pinMode(pinpX, OUTPUT);
    pinMode(pinnX, OUTPUT);
    pinMode(pinpY, OUTPUT);
    pinMode(pinnY, OUTPUT);

    digitalWrite(pinpX, HIGH);
    digitalWrite(pinnX, HIGH);
    digitalWrite(pinpY, HIGH);
    digitalWrite(pinpX, HIGH);

    delay(5);
    configureDAC();
    }


    void loop(){
    if(!adjusted){
    coarseAdjustment();
    adjusted = true;
    }
    scan();
    }

    void configureDAC(){
    digitalWrite(pinpX, LOW);
    digitalWrite(pinnX, LOW);
    digitalWrite(pinpY, LOW);
    digitalWrite(pinnY, LOW);

    byte comByte = 0b00100100; //Command byte, öppnar skrivning till Command Register (CMR)
    byte byte1 = 0b00100010;
    byte byte2 = 0b10100000; //lite oklart om det här är rätt, sätter DAC:en i self-cal mode

    byte comByte2 = 0b00100100; //Command byte, öppnar skrivning till Command Register (CMR)
    byte byte3 = 0b00100010;
    byte byte4 = 0b10100001; //lite oklart om det här är rätt, sätter DAC:en i self-cal mode


    delayMicroseconds(6);
    SPI.transfer(comByte);
    SPI.transfer(byte1);
    SPI.transfer(byte2);

    delay(1000);
    SPI.transfer(comByte2);
    SPI.transfer(byte3);
    SPI.transfer(byte4);
    digitalWrite(pinpX, HIGH);
    digitalWrite(pinnX, HIGH);
    digitalWrite(pinpY, HIGH);
    digitalWrite(pinnY, HIGH);
    delay(500);
    }


    void stepper(int xw){ //stegmotor
    for (int x=0;x
    <xw
    ;x++){
    switch(steps){
    case 0:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, HIGH);
    break;
    case 1:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, HIGH);
    break;
    case 2:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    break;
    case 3:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    break;
    case 4:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, LOW);
    break;
    case 5:
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, HIGH);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, LOW);
    break;
    case 6:
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, LOW);
    break;
    case 7:
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, HIGH);
    break;
    default:
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, LOW);
    break;
    }
    delayMicroseconds(10);
    SetDirection();
    }
    }


    void SetDirection(){
    if(stepperDirec==1){
    steps++;
    }
    if(stepperDirec==0){
    steps--;
    }
    if(steps>7){
    steps=0;
    }
    if(steps<0){
    steps=7;
    }
    }


    void setDAC(long voltage) {
    /**Adjusts all quadrants */
    // 1048575 == 5V
    digitalWrite(pinpX, LOW);
    digitalWrite(pinnX, LOW);
    digitalWrite(pinpY, LOW);
    digitalWrite(pinnY, LOW);
    byte selectDIR = 0b01000000; //Command byte, öppnar skrivning till Data Input Register (DIR)

    byte MSB = (voltage & 0x000ff000UL) >> 12;
    byte MiddleByte = (voltage & 0x00000ff0UL) >> 4;
    byte LSB = (voltage & 0x0000000fUL) << 4;

    SPI.transfer(selectDIR);
    SPI.transfer(MSB);
    SPI.transfer(MiddleByte);
    SPI.transfer(LSB);
    digitalWrite(pinpX, HIGH);
    digitalWrite(pinnX, HIGH);
    digitalWrite(pinpY, HIGH);
    digitalWrite(pinnY, HIGH);
    }

    void setDACPin(long voltage, int pin){
    /**Adjusts specific quadrant **/
    digitalWrite(pin, LOW);
    byte selectDIR = 0b01000000; //Command byte, öppnar skrivning till Data Input Register (DIR)

    byte MSB = (voltage & 0x000ff000UL) >> 12;
    byte MiddleByte = (voltage & 0x00000ff0UL) >> 4;
    byte LSB = (voltage & 0x0000000fUL) << 4;

    SPI.transfer(selectDIR);
    SPI.transfer(MSB);
    SPI.transfer(MiddleByte);
    SPI.transfer(LSB);
    digitalWrite(pin, HIGH);
    }

    void retractPiezo() {
    /**Resets piezo **/
    pX = 0;
    nX = 0;
    pY = 0;
    nY = 0;
    setDAC(0);
    }

    void stepAllPiezo(){
    pX += 256;
    nX += 256;
    pY += 256;
    nY += 256;
    setDAC(pX);
    }

    void bstepAllPiezo(){
    pX -= 256;
    nX -= 256;
    pY -= 256;
    nY -= 256;
    setDAC(pX);
    }

    void stepPiezo() {
    /**Takes a step with the probe **/
    pX += Vref;
    nX += Vref;
    pY += Vref;
    nY += Vref;

    movePiezo();
    }


    void bstepPiezo() {
    /**Takes a step back with the probe **/
    pX -= Vref;
    nX -= Vref;
    pY -= Vref;
    nY -= Vref;

    movePiezo();
    }


    void adjustPiezo() {
    /**Sets a stable tunneling current **/

    while (tunnelRead < tunnelRef - marginal || tunnelRead > tunnelRef + marginal) {
    tunnelRead = analogRead(inputPin);
    if (tunnelRead < tunnelRef - marginal) {
    stepPiezo();
    }
    else if (tunnelRead > tunnelRef + marginal) {
    bstepPiezo();
    }
    }

    //Serial.println("Probe adjusted to reference");
    }


    void movePiezo() {
    /**Moves probe to the defined points **/
    setDACPin(pinpX,pX);
    setDACPin(pinnX,nX);
    setDACPin(pinpY,pY);
    setDACPin(pinnY,nY);
    }


    void moveAdjustRead() {
    movePiezo(); //moves piezo to nX,pX,pY,nY
    adjustPiezo(); //sets current to reference
    tunnelRead = analogRead(inputPin);
    }

    void saveData(){
    scanArray[currentPos] = pX;
    scanArray[currentPos + 1] = nX;
    scanArray[currentPos + 2] = pY;
    scanArray[currentPos + 3] = nY;
    currentPos = currentPos + 4;
    }

    void scan() {
    /** SCAN **/
    pX += 0;
    nX += N/2 * Vref; //Är det här rätt?
    pY += M/2 * Vref;
    nY += 0;

    int dir = 1; // 1 = up, -1 = down

    moveAdjustRead();
    saveData();
    //Serial.println(tunnelRead);
    // send pX,nX,pY,nY //send data to computer through serial communication. i.e read data into text file
    for(int i = 0; i < N; i++) {
    if (dir == 1) {
    for(int k = 0; k < M/2; k++) { // UP
    nY -= Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    for(int n = 0; n < M/2; n++) { // UP
    pY += Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    dir = -1;
    }
    else if (dir == -1) { // DOWN
    for(int k = 0; k < M/2; k++) {
    pY -= Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    for(int n = 0; n > M/2; n++) { // DOWN
    nY += Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    dir = 1;
    }
    if(nX > 0) {
    nX -= Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    else {
    pX += Vref;
    moveAdjustRead();
    //Serial.println(tunnelRead);
    saveData();
    }
    }
    transferData();
    }

    void transferData(){
    Serial.begin(9600);
    for(int i = 0; i < 1600; i++){
    Serial.println(scanArray[i]);
    }
    Serial.end();
    }

    void coarseAdjustment() {

    long piezo = 0;
    setDAC(0);

    while(!current){
    piezo = 0;
    stepper(1);
    while(piezo < 250000){
    piezo = piezo + 2500;
    setDAC(piezo);
    tunnelRead = analogRead(A1);
    if(tunnelRead > tunnelRef - marginal){
    current = true;
    stepperDirec = false;
    stepper(1);
    }

    }

    delay(1);
    }


    boolean stable = false;
    int stableCounter = 0;
    tunnelRead = analogRead(A1);

    while(!stable){
    if(tunnelRead < tunnelRef - marginal){
    if(piezo >= 1048575 - M){
    stepperDirec = true;
    stepper(1);
    delay(3);
    }else{
    piezo = piezo + 5;
    setDAC(piezo);
    }
    stableCounter = 0;
    }else if(tunnelRead > tunnelRef + marginal){
    if(piezo <= M){
    stepperDirec = false;
    stepper(1);
    delay(3);
    }else{
    piezo = piezo - 5;
    setDAC(piezo);
    }
    stableCounter = 0;
    }else{
    stableCounter++;
    if(stableCounter >= 5){
    stable = true;
    }
    }
    tunnelRead = analogRead(A1);
    }
    pX = piezo;
    nX = piezo;
    nY = piezo;
    pY = piezo;
    }

</xmp>

<h1></h1>

</body>
</html>